
<!DOCTYPE html>
<html lang="zh-cn">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="莱茵河畔的固执">
    <title>排序算法 - 莱茵河畔的固执</title>
    <meta name="author" content="BillReus">
    
        <meta name="keywords" content="算法,排序">
    
    
        <link rel="icon" href="https://picccc.oss-cn-shenzhen.aliyuncs.com/img/正恩.jpg?x-oss-process=image/resize,l_40,w_40">
    
    
        <link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml">
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"BillReus","sameAs":["https://github.com/billreus","/#search","/#about"],"image":"https://picccc.oss-cn-shenzhen.aliyuncs.com/img/泰迪.jpg?x-oss-process=image/resize,l_90,w_90"},"articleBody":"常见的七种排序算法\n冒泡排序原理属于交换排序，两两比较交换，遍历一遍即确定最大数\n程序1234567891011public void bubbleSort(int[] arrays)&#123;    for(int i=0; i&lt;arrays.length-1; i++)&#123;        for(int j=0; j&lt;arrays.length-1-i; j++)&#123;            if(arrays[j] &gt; arrays[j+1])&#123;                int tmp = arrays[j];                arrays[j] = arrays[j+1];                arrays[j+1] = tmp;            &#125;        &#125;    &#125;&#125;\n优化思路：如果一趟排序没有位置交换，即数组已经有序。\n123456789101112131415public void bubbleSort(int[] arrays)&#123;    for(int i=0; i&lt;arrays.length-1; i++)&#123;        int isChange = 0;        for(int j=0; j&lt;arrays.length-1-i; j++)&#123;            if(arrays[j] &gt; arrays[j+1])&#123;                int tmp = arrays[j];                arrays[j] = arrays[j+1];                arrays[j+1] = tmp;                isChange = 1;            &#125;        &#125;        if(isChange == 0)            break;    &#125;&#125;\n复杂度时间：O(N^2)\n是否稳定：稳定\n空间：O(1)\n选择排序原理每次遍历从数组中找出最小值放到最左边\n程序12345678910111213141516public void selectSort(int[] arrays)&#123;    int n = arrays.length;    int minIndex;    for(int i=0; i&lt;n; i++)&#123;        minIndex = i;        for(int j=i+1; j&lt;n; j++)&#123;            if(arrays[j] &lt; arrays[minIndex])                minIndex = j;        &#125;        if(minIndex != i)&#123;            int tmp = arrays[i];            arrays[i] = arrays[minIndex];            arrays[minIndex] = tmp;        &#125;    &#125;&#125;\n复杂度时间：O(N^2)\n是否稳定：不稳定（相同的数有可能前者会与后面更小的数交换了位置）\n空间：O(1)\n直接插入排序原理把数组分成有序和无序，每次从无序中取出一个放入有序队列\n程序12345678910public void insertSort(int[] arrays)&#123;    int n = arrays.length;    for(int i=1; i&lt;n; i++)&#123;        for(int j=i; j&gt;0&amp;&amp;(arrays[j]&lt;arrays[j-1]); j--)&#123;            int tmp = arrays[j];            arrays[j] = arrays[j-1];            arrays[j-1] = tmp;        &#125;    &#125;&#125;\n复杂度时间：O(N^2)\n是否稳定：稳定\n空间：O(1)\n希尔排序原理对间隔h的数进行排序，不断减小h，最后h=1即数组有序。\n程序1234567891011121314151617public void shellSort(int[] arrays)&#123;    int n = arrays.length;    int h = 1;    while(h&lt;n/3)&#123;        h=3*h+1; //1,4,13,40...    &#125;    while(h&gt;=1)&#123;        for(int i=1; i&lt;n; i++)&#123;        \tfor(int j=i; j&gt;0&amp;&amp;(arrays[j]&lt;arrays[j-1]); j--)&#123;            \tint tmp = arrays[j];            \tarrays[j] = arrays[j-1];            \tarrays[j-1] = tmp;        \t&#125;    \t&#125;        h = h/3;    &#125;&#125;\n复杂度时间：O(N^(3/2))\n是否稳定：不稳定\n空间：O(1)\n快速排序原理交换排序基于递归，从数组左边选择一个数作为基准值，比基准值小的放前面，比基准值大的放后面。\n程序12345678910111213141516171819202122public void sort(int[] arrays)&#123;    int left = 0;\tint right = arrays.length-1;    qiuckSort(arrays, left, right);&#125;public void qiuckSort(int[] a, int l, int r)&#123;    if(l&gt;=r) return ;    int mid = l;//基准值    int start = l+1, end = r;    while(start&lt;end)&#123;        while(a[end]&gt;=a[mid] &amp;&amp; start&lt;end)            end--;        while(a[start]&lt;=a[mid] &amp;&amp; start&lt;end)            start++;        if(start&lt;end)            swap(a[start], a[end]);    &#125;    swap(a[l], a[start]);    quickSort(a, l, end-1);    quickSort(a, end+1, r);&#125;\n优化三向切分，把数组切分成小于、等于、大于。对于有大量重复元素的数组可以更高效。\n12345678910111213141516171819202122232425public void sort(int[] arrays)&#123;    int left = 0;\tint right = arrays.length-1;    qiuckSort(arrays, left, right);&#125;public void qiuckSort(int[] a, int l, int r)&#123;    if(l&gt;=r) return ;    int mid = l;//每次使用的比较值    int start = l+1, end = r;    while(start&lt;=end)&#123;        int cmp = a[start] - a[mid];        if(cmp&lt;0)&#123;//右边比比较值小            swap(a[mid++], a[start++]);//交换位置，比较值位置等于前移一位        &#125;        else if(cmp&gt;0)&#123;//右边比比较值大            swap(a[start], a[end--]);//把大的放到最后，下次大的放在倒数第二        &#125;        else&#123;            start++;        &#125;    &#125;    quickSort(a, l, mid-1);    quickSort(a, end+1, r);&#125;\n复杂度时间：O(N^lgN)\n是否稳定：不稳定\n空间：O(NlgN)\n归并排序原理将数组拆分成两部分，分别排序然后归并。自顶向下即将一个大数组分成两个小数组。\n程序12345678910111213141516171819202122232425262728public void mergeSortUpDown(int[] a, int start, int end)&#123;    if(a==null || start&gt;=end)        return ;    int mid = (end+start)/2;    mergeSortUpDown(a, start, mid);    mergeSortUpDown(a, mid+1, end);    merge(a, start, mid, end);&#125;//将两个相邻的有序区间合并成一个public void merge(int[] a, int start, int mid, int end)&#123;    int[] tmp = new int[end-start+1];    int i = start;    int j = mid+1;    for(int k=start; k&lt;=end; k++)&#123;        tmp[k] = a[k];// 将数据复制到辅助数组    &#125;    for(int k=start; k&lt;=end; k++)&#123;        if(i &gt; mid)&#123;左边没有数存右边            a[k] = tmp[j++];        &#125;else if(j &gt; end)&#123;//右边没有数，存左边            a[k] = tmp[i++];        &#125;else if(tmp[i] - tmp[j] &lt;= 0)&#123;//合并数组中左边较小，存            a[k] = tmp[i++];        &#125;else&#123;//合并数组右边较小，存            a[k] = tmp[j++];        &#125;    &#125;&#125;\n复杂度时间：O(NlgN)\n是否稳定：稳定\n空间：O(NlgN)\n堆排序原理用数组模拟二叉树的数据结构存储数据，每次把最大值放在堆顶，然后交换数据把最大值放到末尾，循环既可。\n其中：当数组第0个位置没有元素时，索引为i的数，左孩子是2i，右孩子是2i+1，父节点是i/2\n程序123456789101112131415161718192021222324public void heapSort(int[] a)&#123;    /**     * 数组第 0 个位置不能有元素     */    int n = a.length - 1;    //构建堆，从倒数第二层开始下沉即可    for(int k=n/2; k &gt;= 1; k--)        sink(a, k, n);    while(n &gt; 1)&#123;        swap(a, 1, n--);//最大值放到最后        sink(a, 1, n);//新的下沉        &#125;&#125;public void sink(int[] a, int k, int n)&#123;//k节点下沉到合适位置    while(2 * k &lt;= n)&#123;//非叶子层        int j = 2 * k;//左孩子        if(j &lt; n &amp;&amp; (a[j] - a[j+1] &lt; 0))//选出两个孩子中大的一个            j++;        if(a[k] - a[j] &gt; 0)//父与子中大的对比            break;        swap(a, k, j);        k = j;    &#125;&#125;\n复杂度时间：O(NlgN)\n是否稳定：不稳定\n空间：O(1)\n现代操作系统很少使用堆排序，因为它无法利用局部性原理进行缓存，也就是数组元素很少和相邻的元素进行比较和交换。\n总结\n\n\n算法\n稳定性\n时间复杂度\n空间复杂度\n备注\n\n\n\n\n选择排序\n×\nN2\n1\n\n\n\n冒泡排序\n√\nN2\n1\n\n\n\n插入排序\n√\nN ~ N2\n1\n时间复杂度和初始顺序有关\n\n\n希尔排序\n×\nN 的若干倍乘于递增序列的长度\n1\n改进版插入排序\n\n\n快速排序\n×\nNlogN\nlogN\n\n\n\n三向切分快速排序\n×\nN ~ NlogN\nlogN\n适用于有大量重复主键\n\n\n归并排序\n√\nNlogN\nN\n\n\n\n堆排序\n×\nNlogN\n1\n无法利用局部性原理\n\n\n\n快速排序是最快的通用排序算法，它的内循环的指令很少，而且它还能利用缓存，因为它总是顺序地访问数据。它的运行时间近似为 ~cNlogN，这里的 c 比其它线性对数级别的排序算法都要小。\nJava 主要排序方法为 java.util.Arrays.sort()，对于原始数据类型使用三向切分的快速排序，对于引用类型使用归并排序。\n","dateCreated":"2019-05-25T15:59:00+08:00","dateModified":"2020-02-16T15:48:46+08:00","datePublished":"2019-05-25T15:59:00+08:00","description":"常见的七种排序算法","headline":"排序算法","image":["https://picccc.oss-cn-shenzhen.aliyuncs.com/img/庙.jpg?x-oss-process=image/resize,l_140,w_140","https://s2.ax1x.com/2019/05/25/Vk5tu6.jpg"],"mainEntityOfPage":{"@type":"WebPage","@id":"/2019/05/25/排序/"},"publisher":{"@type":"Organization","name":"BillReus","sameAs":["https://github.com/billreus","/#search","/#about"],"image":"https://picccc.oss-cn-shenzhen.aliyuncs.com/img/泰迪.jpg?x-oss-process=image/resize,l_90,w_90","logo":{"@type":"ImageObject","url":"https://picccc.oss-cn-shenzhen.aliyuncs.com/img/泰迪.jpg?x-oss-process=image/resize,l_90,w_90"}},"url":"/2019/05/25/排序/","keywords":"排序","thumbnailUrl":"https://picccc.oss-cn-shenzhen.aliyuncs.com/img/庙.jpg?x-oss-process=image/resize,l_140,w_140"}</script>
    <meta name="description" content="常见的七种排序算法">
<meta name="keywords" content="算法,排序">
<meta property="og:type" content="blog">
<meta property="og:title" content="排序算法">
<meta property="og:url" content="/2019/05/25/排序/index.html">
<meta property="og:site_name" content="莱茵河畔的固执">
<meta property="og:description" content="常见的七种排序算法">
<meta property="og:locale" content="zh-cn">
<meta property="og:updated_time" content="2020-02-16T07:48:46.835Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="排序算法">
<meta name="twitter:description" content="常见的七种排序算法">
    
    
        
    
    
        <meta property="og:image" content="https://picccc.oss-cn-shenzhen.aliyuncs.com/img/泰迪.jpg?x-oss-process=image/resize,l_90,w_90"/>
    
    
        <meta property="og:image" content="https://picccc.oss-cn-shenzhen.aliyuncs.com/img/庙.jpg?x-oss-process=image/resize,l_140,w_140"/>
        <meta class="swiftype" name="image" data-type="enum" content="https://picccc.oss-cn-shenzhen.aliyuncs.com/img/庙.jpg?x-oss-process=image/resize,l_140,w_140"/>
    
    
        <meta property="og:image" content="https://s2.ax1x.com/2019/05/25/Vk5tu6.jpg"/>
        <meta class="swiftype" name="image" data-type="enum" content="https://s2.ax1x.com/2019/05/25/Vk5tu6.jpg"/>
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-inw8pl0vcsjxbkjilkyx1wcvyzpyb5lstkp9pk3qndyvskleosndshovid8c.min.css">
    <!--STYLES END-->
    

    

    
        
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/ " aria-label>
            莱茵河畔的固执
        </a>
    </div>
    
        
            <a class="header-right-picture " href="#about" aria-label="打开链接: /#about">
        
        
            <img class="header-picture" src="https://picccc.oss-cn-shenzhen.aliyuncs.com/img/泰迪.jpg?x-oss-process=image/resize,l_90,w_90" alt="作者的图片">
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a href="/#about" aria-label="阅读有关作者的更多信息">
                    <img class="sidebar-profile-picture" src="https://picccc.oss-cn-shenzhen.aliyuncs.com/img/泰迪.jpg?x-oss-process=image/resize,l_90,w_90" alt="作者的图片">
                </a>
                <h4 class="sidebar-profile-name">BillReus</h4>
                
                    <h5 class="sidebar-profile-bio"><p>author.bio</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/ " title="首页">
                    
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首页</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/all-categories" title="分类">
                    
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分类</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/all-tags" title="标签">
                    
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">标签</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/all-archives" title="归档">
                    
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">归档</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="https://github.com/billreus" title="GitHub">
                    
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link open-algolia-search" href="#search" title="搜索">
                    
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">搜索</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="#about" title="关于">
                    
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">关于</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
        <div class="post-header-cover
                    text-left
                    " style="background-image:url('https://s2.ax1x.com/2019/05/25/Vk5tu6.jpg');" data-behavior="4">
            
                <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            排序算法
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2019-05-25T15:59:00+08:00">
	
		    5月 25, 2019
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/算法/">算法</a>


    
</div>

    
</div>

            
        </div>

            <div id="main" data-behavior="4"
                 class="hasCover
                        hasCoverMetaIn
                        hasCoverCaption">
                
<article class="post">
    
        <span class="post-header-cover-caption caption">米特奥拉-希腊</span>
    
    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <p>常见的七种排序算法<br><a id="more"></a><br></p><h1 id="table-of-contents">目录</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#冒泡排序"><span class="toc-text">冒泡排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#原理"><span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#程序"><span class="toc-text">程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#优化"><span class="toc-text">优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#复杂度"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#选择排序"><span class="toc-text">选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#原理-1"><span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#程序-1"><span class="toc-text">程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#复杂度-1"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#直接插入排序"><span class="toc-text">直接插入排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#原理-2"><span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#程序-2"><span class="toc-text">程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#复杂度-2"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#希尔排序"><span class="toc-text">希尔排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#原理-3"><span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#程序-3"><span class="toc-text">程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#复杂度-3"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#快速排序"><span class="toc-text">快速排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#原理-4"><span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#程序-4"><span class="toc-text">程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#优化-1"><span class="toc-text">优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#复杂度-4"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#归并排序"><span class="toc-text">归并排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#原理-5"><span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#程序-5"><span class="toc-text">程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#复杂度-5"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#堆排序"><span class="toc-text">堆排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#原理-6"><span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#程序-6"><span class="toc-text">程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#复杂度-6"><span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li></ol><p></p>
<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>属于交换排序，两两比较交换，遍历一遍即确定最大数</p>
<h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arrays)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arrays.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;arrays.length-<span class="number">1</span>-i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arrays[j] &gt; arrays[j+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = arrays[j];</span><br><span class="line">                arrays[j] = arrays[j+<span class="number">1</span>];</span><br><span class="line">                arrays[j+<span class="number">1</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>思路：如果一趟排序没有位置交换，即数组已经有序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arrays)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arrays.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> isChange = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;arrays.length-<span class="number">1</span>-i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arrays[j] &gt; arrays[j+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = arrays[j];</span><br><span class="line">                arrays[j] = arrays[j+<span class="number">1</span>];</span><br><span class="line">                arrays[j+<span class="number">1</span>] = tmp;</span><br><span class="line">                isChange = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isChange == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间：O(N^2)</p>
<p>是否稳定：稳定</p>
<p>空间：O(1)</p>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>每次遍历从数组中找出最小值放到最左边</p>
<h2 id="程序-1"><a href="#程序-1" class="headerlink" title="程序"></a>程序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] arrays)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arrays.length;</span><br><span class="line">    <span class="keyword">int</span> minIndex;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">        minIndex = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arrays[j] &lt; arrays[minIndex])</span><br><span class="line">                minIndex = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(minIndex != i)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = arrays[i];</span><br><span class="line">            arrays[i] = arrays[minIndex];</span><br><span class="line">            arrays[minIndex] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间：O(N^2)</p>
<p>是否稳定：不稳定（相同的数有可能前者会与后面更小的数交换了位置）</p>
<p>空间：O(1)</p>
<h1 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h1><h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><p>把数组分成有序和无序，每次从无序中取出一个放入有序队列</p>
<h2 id="程序-2"><a href="#程序-2" class="headerlink" title="程序"></a>程序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arrays)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arrays.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&gt;<span class="number">0</span>&amp;&amp;(arrays[j]&lt;arrays[j-<span class="number">1</span>]); j--)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = arrays[j];</span><br><span class="line">            arrays[j] = arrays[j-<span class="number">1</span>];</span><br><span class="line">            arrays[j-<span class="number">1</span>] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="复杂度-2"><a href="#复杂度-2" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间：O(N^2)</p>
<p>是否稳定：稳定</p>
<p>空间：O(1)</p>
<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><h2 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h2><p>对间隔h的数进行排序，不断减小h，最后h=1即数组有序。</p>
<h2 id="程序-3"><a href="#程序-3" class="headerlink" title="程序"></a>程序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arrays)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arrays.length;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(h&lt;n/<span class="number">3</span>)&#123;</span><br><span class="line">        h=<span class="number">3</span>*h+<span class="number">1</span>; <span class="comment">//1,4,13,40...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(h&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)&#123;</span><br><span class="line">        	<span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&gt;<span class="number">0</span>&amp;&amp;(arrays[j]&lt;arrays[j-<span class="number">1</span>]); j--)&#123;</span><br><span class="line">            	<span class="keyword">int</span> tmp = arrays[j];</span><br><span class="line">            	arrays[j] = arrays[j-<span class="number">1</span>];</span><br><span class="line">            	arrays[j-<span class="number">1</span>] = tmp;</span><br><span class="line">        	&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">        h = h/<span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="复杂度-3"><a href="#复杂度-3" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间：O(N^(3/2))</p>
<p>是否稳定：不稳定</p>
<p>空间：O(1)</p>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h2><p>交换排序基于递归，从数组左边选择一个数作为基准值，比基准值小的放前面，比基准值大的放后面。</p>
<h2 id="程序-4"><a href="#程序-4" class="headerlink" title="程序"></a>程序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arrays)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> right = arrays.length-<span class="number">1</span>;</span><br><span class="line">    qiuckSort(arrays, left, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">qiuckSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid = l;<span class="comment">//基准值</span></span><br><span class="line">    <span class="keyword">int</span> start = l+<span class="number">1</span>, end = r;</span><br><span class="line">    <span class="keyword">while</span>(start&lt;end)&#123;</span><br><span class="line">        <span class="keyword">while</span>(a[end]&gt;=a[mid] &amp;&amp; start&lt;end)</span><br><span class="line">            end--;</span><br><span class="line">        <span class="keyword">while</span>(a[start]&lt;=a[mid] &amp;&amp; start&lt;end)</span><br><span class="line">            start++;</span><br><span class="line">        <span class="keyword">if</span>(start&lt;end)</span><br><span class="line">            swap(a[start], a[end]);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(a[l], a[start]);</span><br><span class="line">    quickSort(a, l, end-<span class="number">1</span>);</span><br><span class="line">    quickSort(a, end+<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h2><p>三向切分，把数组切分成小于、等于、大于。对于有大量重复元素的数组可以更高效。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arrays)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> right = arrays.length-<span class="number">1</span>;</span><br><span class="line">    qiuckSort(arrays, left, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">qiuckSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid = l;<span class="comment">//每次使用的比较值</span></span><br><span class="line">    <span class="keyword">int</span> start = l+<span class="number">1</span>, end = r;</span><br><span class="line">    <span class="keyword">while</span>(start&lt;=end)&#123;</span><br><span class="line">        <span class="keyword">int</span> cmp = a[start] - a[mid];</span><br><span class="line">        <span class="keyword">if</span>(cmp&lt;<span class="number">0</span>)&#123;<span class="comment">//右边比比较值小</span></span><br><span class="line">            swap(a[mid++], a[start++]);<span class="comment">//交换位置，比较值位置等于前移一位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cmp&gt;<span class="number">0</span>)&#123;<span class="comment">//右边比比较值大</span></span><br><span class="line">            swap(a[start], a[end--]);<span class="comment">//把大的放到最后，下次大的放在倒数第二</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    quickSort(a, l, mid-<span class="number">1</span>);</span><br><span class="line">    quickSort(a, end+<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="复杂度-4"><a href="#复杂度-4" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间：O(N^lgN)</p>
<p>是否稳定：不稳定</p>
<p>空间：O(NlgN)</p>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h2 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h2><p>将数组拆分成两部分，分别排序然后归并。自顶向下即将一个大数组分成两个小数组。</p>
<h2 id="程序-5"><a href="#程序-5" class="headerlink" title="程序"></a>程序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSortUpDown</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="keyword">null</span> || start&gt;=end)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid = (end+start)/<span class="number">2</span>;</span><br><span class="line">    mergeSortUpDown(a, start, mid);</span><br><span class="line">    mergeSortUpDown(a, mid+<span class="number">1</span>, end);</span><br><span class="line">    merge(a, start, mid, end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将两个相邻的有序区间合并成一个</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> start, <span class="keyword">int</span> mid, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[end-start+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i = start;</span><br><span class="line">    <span class="keyword">int</span> j = mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=start; k&lt;=end; k++)&#123;</span><br><span class="line">        tmp[k] = a[k];<span class="comment">// 将数据复制到辅助数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=start; k&lt;=end; k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; mid)&#123;左边没有数存右边</span><br><span class="line">            a[k] = tmp[j++];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j &gt; end)&#123;<span class="comment">//右边没有数，存左边</span></span><br><span class="line">            a[k] = tmp[i++];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tmp[i] - tmp[j] &lt;= <span class="number">0</span>)&#123;<span class="comment">//合并数组中左边较小，存</span></span><br><span class="line">            a[k] = tmp[i++];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//合并数组右边较小，存</span></span><br><span class="line">            a[k] = tmp[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="复杂度-5"><a href="#复杂度-5" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间：O(NlgN)</p>
<p>是否稳定：稳定</p>
<p>空间：O(NlgN)</p>
<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><h2 id="原理-6"><a href="#原理-6" class="headerlink" title="原理"></a>原理</h2><p>用数组模拟二叉树的数据结构存储数据，每次把最大值放在堆顶，然后交换数据把最大值放到末尾，循环既可。</p>
<p>其中：当数组第0个位置没有元素时，索引为i的数，左孩子是2i，右孩子是2i+1，父节点是i/2</p>
<h2 id="程序-6"><a href="#程序-6" class="headerlink" title="程序"></a>程序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组第 0 个位置不能有元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> n = a.length - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//构建堆，从倒数第二层开始下沉即可</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=n/<span class="number">2</span>; k &gt;= <span class="number">1</span>; k--)</span><br><span class="line">        sink(a, k, n);</span><br><span class="line">    <span class="keyword">while</span>(n &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        swap(a, <span class="number">1</span>, n--);<span class="comment">//最大值放到最后</span></span><br><span class="line">        sink(a, <span class="number">1</span>, n);<span class="comment">//新的下沉    </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> k, <span class="keyword">int</span> n)</span></span>&#123;<span class="comment">//k节点下沉到合适位置</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">2</span> * k &lt;= n)&#123;<span class="comment">//非叶子层</span></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">2</span> * k;<span class="comment">//左孩子</span></span><br><span class="line">        <span class="keyword">if</span>(j &lt; n &amp;&amp; (a[j] - a[j+<span class="number">1</span>] &lt; <span class="number">0</span>))<span class="comment">//选出两个孩子中大的一个</span></span><br><span class="line">            j++;</span><br><span class="line">        <span class="keyword">if</span>(a[k] - a[j] &gt; <span class="number">0</span>)<span class="comment">//父与子中大的对比</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        swap(a, k, j);</span><br><span class="line">        k = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="复杂度-6"><a href="#复杂度-6" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间：O(NlgN)</p>
<p>是否稳定：不稳定</p>
<p>空间：O(1)</p>
<p>现代操作系统很少使用堆排序，因为它无法利用局部性原理进行缓存，也就是数组元素很少和相邻的元素进行比较和交换。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><table>
<thead>
<tr>
<th>算法</th>
<th>稳定性</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>选择排序</td>
<td>×</td>
<td>N2</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>冒泡排序</td>
<td>√</td>
<td>N2</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>插入排序</td>
<td>√</td>
<td>N ~ N2</td>
<td>1</td>
<td>时间复杂度和初始顺序有关</td>
</tr>
<tr>
<td>希尔排序</td>
<td>×</td>
<td>N 的若干倍乘于递增序列的长度</td>
<td>1</td>
<td>改进版插入排序</td>
</tr>
<tr>
<td>快速排序</td>
<td>×</td>
<td>NlogN</td>
<td>logN</td>
<td></td>
</tr>
<tr>
<td>三向切分快速排序</td>
<td>×</td>
<td>N ~ NlogN</td>
<td>logN</td>
<td>适用于有大量重复主键</td>
</tr>
<tr>
<td>归并排序</td>
<td>√</td>
<td>NlogN</td>
<td>N</td>
<td></td>
</tr>
<tr>
<td>堆排序</td>
<td>×</td>
<td>NlogN</td>
<td>1</td>
<td>无法利用局部性原理</td>
</tr>
</tbody>
</table>
<p>快速排序是最快的通用排序算法，它的内循环的指令很少，而且它还能利用缓存，因为它总是顺序地访问数据。它的运行时间近似为 ~cNlogN，这里的 c 比其它线性对数级别的排序算法都要小。</p>
<p>Java 主要排序方法为 java.util.Arrays.sort()，对于原始数据类型使用三向切分的快速排序，对于引用类型使用归并排序。</p>

            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">标签</span><br>
                
    <a class="tag tag--primary tag--small t-link" href="/tags/排序/">排序</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a class="post-action-btn btn btn--default tooltip--top" href="/2019/06/12/史诗/" data-tooltip="史诗" aria-label="上一篇: 史诗">
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a class="post-action-btn btn btn--default tooltip--top" href="/2019/05/20/广场/" data-tooltip="广场" aria-label="下一篇: 广场">
                    
                        <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen">
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2022 BillReus. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a class="post-action-btn btn btn--default tooltip--top" href="/2019/06/12/史诗/" data-tooltip="史诗" aria-label="上一篇: 史诗">
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a class="post-action-btn btn btn--default tooltip--top" href="/2019/05/20/广场/" data-tooltip="广场" aria-label="下一篇: 广场">
                    
                        <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen">
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                

            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="https://picccc.oss-cn-shenzhen.aliyuncs.com/img/泰迪.jpg?x-oss-process=image/resize,l_90,w_90" alt="作者的图片">
        
            <h4 id="about-card-name">BillReus</h4>
        
            <div id="about-card-bio"><p>author.bio</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br>
                <p>author.job</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br>
                China
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('https://picccc.oss-cn-shenzhen.aliyuncs.com/img/背景.jpg?x-oss-process=image/resize,l_730,w_500');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/script-iupfu4cvozqvsi1hhazhbob6uip1kfivmhmcidsf0ja5ike2vagngtevm6j3.min.js"></script>
<!--SCRIPTS END-->


    




    </body>
</html>
